/**
 * @fileoverview LoliCode script generator for OpenBullet 2
 * @module @/lib/generator
 */

import type { SemanticHarEntry } from '@/lib/parser/types';
import type { DependencyMatrix } from '@/lib/analyzer/types';
import { RequestBlockBuilder } from './builders/RequestBlockBuilder';
import { KeycheckBlockBuilder } from './builders/KeycheckBlockBuilder';
import { ParseBlockBuilder } from './builders/ParseBlockBuilder';
import { LoliCodeValidator } from './validators/LoliCodeValidator';
import { retry } from '../utils';

/**
 * Configuration for LoliCode generation
 */
export interface LoliCodeConfig {
  /** Indices of requests to include */
  selectedIndices: number[];
  
  /** Custom headers per request index */
  customHeaders?: Record<number, CustomHeader[]>;
  
  /** Custom assertions per request index */
  customAssertions?: Record<number, CustomAssertion[]>;
  
  /** Variable extraction rules per request index */
  variableExtractions?: Record<number, VariableExtraction[]>;
  
  /** Global script settings */
  settings?: {
    useProxy?: boolean;
    followRedirects?: boolean;
    timeout?: number;
    retryCount?: number;
  };
}

export interface CustomHeader {
  key: string;
  value: string;
  enabled: boolean;
}

export interface CustomAssertion {
  type: 'status' | 'contains' | 'regex' | 'json-path';
  value: string;
  expectedResult?: string;
  action: 'success' | 'fail' | 'retry' | 'ban';
}

export interface VariableExtraction {
  type: 'regex' | 'json' | 'css' | 'xpath';
  pattern: string;
  variableName: string;
  isGlobal: boolean;
}

/**
 * Generate syntactically valid LoliCode from HAR analysis
 */
export class LoliCodeGenerator {
  private readonly requestBuilder: RequestBlockBuilder;
  private readonly keycheckBuilder: KeycheckBlockBuilder;
  private readonly parseBuilder: ParseBlockBuilder;
  private readonly validator: LoliCodeValidator;
  private readonly retries: number;

  constructor(retries = 0) {
    this.requestBuilder = new RequestBlockBuilder();
    this.keycheckBuilder = new KeycheckBlockBuilder();
    this.parseBuilder = new ParseBlockBuilder();
    this.validator = new LoliCodeValidator();
    this.retries = retries;
  }

  /**
   * Generate complete LoliCode script
   * @param config - Generation configuration
   * @param entries - Filtered HAR entries
   * @param dependencyMatrix - Request dependencies
   * @returns Valid LoliCode script
   * @throws {Error} INVALID_CONFIG - Invalid configuration
   */
  public async generate(
    config: LoliCodeConfig,
    entries: SemanticHarEntry[],
    dependencyMatrix: DependencyMatrix
  ): Promise<string> {
    return retry(async () => {
      // Validate configuration
      this.validateConfig(config, entries.length);

      // Sort selected indices by dependency order
      const sortedIndices = this.sortByDependencies(
        config.selectedIndices,
        dependencyMatrix
      );

      // Generate script sections
      const sections: string[] = [];

      // Add header comment
      sections.push(this.generateHeader());

      // Add settings block if provided
      if (config.settings) {
        sections.push(this.generateSettings(config.settings));
      }

      // Generate request blocks
      for (const index of sortedIndices) {
        const entry = entries[index];
        const requestSection = this.generateRequestSection(
          entry,
          index,
          config
        );
        sections.push(requestSection);
      }

      // Add footer
      sections.push(this.generateFooter());

      // Join sections
      const script = sections.join('\n\n');

      // Validate generated script
      const validation = this.validator.validate(script);
      if (!validation.isValid) {
        console.error("Generated invalid LoliCode:", validation.errors);
        throw new Error(`Generated invalid LoliCode: ${validation.errors[0]}`);
      }

      return script;
    }, this.retries);
  }
  
  /**
   * Validate configuration
   */
  private validateConfig(config: LoliCodeConfig, entryCount: number): void {
    if (!config.selectedIndices || config.selectedIndices.length === 0) {
      throw new Error('INVALID_CONFIG: No requests selected');
    }
    
    for (const index of config.selectedIndices) {
      if (index < 0 || index >= entryCount) {
        throw new Error(`INVALID_CONFIG: Invalid index ${index}`);
      }
    }
  }
  
  /**
   * Sort indices by dependency order
   */
  private sortByDependencies(
    indices: number[],
    matrix: DependencyMatrix
  ): number[] {
    return matrix.topologicalOrder.filter(i => indices.includes(i));
  }
  
  /**
   * Generate header comment
   */
  private generateHeader(): string {
    return `# ═══════════════════════════════════════════════════════════════
# Generated by HAR2LoliCode
# Date: ${new Date().toISOString()}
# Description: Automated script from HAR analysis
# ═══════════════════════════════════════════════════════════════`;
  }
  
  /**
   * Generate settings block
   */
  private generateSettings(settings: NonNullable<LoliCodeConfig['settings']>): string {
    const lines: string[] = ['SETTINGS'];
    
    if (settings.useProxy) {
      lines.push('  UseProxy: true');
    }
    
    if (settings.followRedirects !== undefined) {
      lines.push(`  FollowRedirects: ${settings.followRedirects}`);
    }
    
    if (settings.timeout) {
      lines.push(`  Timeout: ${settings.timeout}`);
    }
    
    if (settings.retryCount) {
      lines.push(`  RetryCount: ${settings.retryCount}`);
    }
    
    return lines.join('\n');
  }
  
  /**
   * Generate request section with all blocks
   */
  private generateRequestSection(
    entry: SemanticHarEntry,
    index: number,
    config: LoliCodeConfig
  ): string {
    const sections: string[] = [];
    
    // Add section comment
    sections.push(`# ─────────────────────────────────────────────────────────────`);
    sections.push(`# Request ${index + 1}: ${entry.request.method} ${new URL(entry.request.url).pathname}`);
    sections.push(`# ─────────────────────────────────────────────────────────────`);
    
    // Generate request block
    const requestBlock = this.requestBuilder.build(
      entry,
      config.customHeaders?.[index]
    );
    sections.push(requestBlock);
    
    // Generate variable extraction if configured
    if (config.variableExtractions?.[index]) {
      for (const extraction of config.variableExtractions[index]) {
        const parseBlock = this.parseBuilder.build(extraction);
        sections.push(parseBlock);
      }
    }
    
    // Generate assertions/keychecks
    if (config.customAssertions?.[index]) {
      for (const assertion of config.customAssertions[index]) {
        const keycheckBlock = this.keycheckBuilder.build(assertion);
        sections.push(keycheckBlock);
      }
    } else {
      // Default status check
      sections.push(this.keycheckBuilder.buildStatusCheck(entry.response.status));
    }
    
    // Add delay between requests
    sections.push('FUNCTION Delay "1000"');
    
    return sections.join('\n');
  }
  
  /**
   * Generate footer
   */
  private generateFooter(): string {
    return `# ═══════════════════════════════════════════════════════════════
# End of generated script
# ═══════════════════════════════════════════════════════════════`;
  }
}

// Export factory function
export async function generateLoliCode(
  config: LoliCodeConfig,
  entries: SemanticHarEntry[],
  dependencyMatrix: DependencyMatrix,
  retries?: number
): Promise<string> {
  const generator = new LoliCodeGenerator(retries);
  return generator.generate(config, entries, dependencyMatrix);
}
