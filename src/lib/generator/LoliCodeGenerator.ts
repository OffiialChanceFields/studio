/**
 * @fileoverview LoliCode script generator for OpenBullet 2
 * @module @/lib/generator
 */

import type { SemanticHarEntry } from '@/lib/parser/types';
import type { DependencyMatrix } from '@/lib/analyzer/types';
import { RequestBlockBuilder } from './builders/RequestBlockBuilder';
import { KeycheckBlockBuilder } from './builders/KeycheckBlockBuilder';
import { ParseBlockBuilder } from './builders/ParseBlockBuilder';
import { LoliCodeValidator } from './validators/LoliCodeValidator';

/**
 * Configuration for LoliCode generation
 */
export interface LoliCodeConfig {
  /** Indices of requests to include */
  selectedIndices: number[];
  
  /** Custom headers per request index */
  customHeaders?: Record<number, CustomHeader[]>;
  
  /** Custom assertions per request index */
  customAssertions?: Record<number, CustomAssertion[]>;
  
  /** Variable extraction rules per request index */
  variableExtractions?: Record<number, VariableExtraction[]>;
  
  /** Global script settings */
  settings?: {
    useProxy?: boolean;
    followRedirects?: boolean;
    timeout?: number;
    retryCount?: number;
  };
}

export interface CustomHeader {
  key: string;
  value: string;
  enabled: boolean;
}

export interface CustomAssertion {
  type: 'status' | 'contains' | 'regex' | 'json-path';
  value: string;
  expectedResult?: string;
  action: 'success' | 'fail' | 'retry' | 'ban';
}

export interface VariableExtraction {
  type: 'regex' | 'json' | 'css' | 'xpath';
  pattern: string;
  variableName: string;
  isGlobal: boolean;
}

/**
 * Generate syntactically valid LoliCode from HAR analysis
 */
export class LoliCodeGenerator {
  private readonly requestBuilder: RequestBlockBuilder;
  private readonly keycheckBuilder: KeycheckBlockBuilder;
  private readonly parseBuilder: ParseBlockBuilder;
  private readonly validator: LoliCodeValidator;

  constructor() {
    this.requestBuilder = new RequestBlockBuilder();
    this.keycheckBuilder = new KeycheckBlockBuilder();
    this.parseBuilder = new ParseBlockBuilder();
    this.validator = new LoliCodeValidator();
  }

  /**
   * Generate complete LoliCode script
   * @param config - Generation configuration
   * @param entries - Filtered HAR entries
   * @param dependencyMatrix - Request dependencies
   * @returns Valid LoliCode script
   * @throws {Error} INVALID_CONFIG - Invalid configuration
   */
  public generate(
    config: LoliCodeConfig,
    entries: SemanticHarEntry[],
    dependencyMatrix: DependencyMatrix
  ): string {
    // Validate configuration
    this.validateConfig(config, entries.length);
    
    // Sort selected indices by dependency order
    const sortedIndices = this.sortByDependencies(
      config.selectedIndices,
      dependencyMatrix
    );
    
    // Generate script sections
    const sections: string[] = [];
    
    // Add header comment
    sections.push(this.generateHeader());
    
    // Add settings block if provided
    if (config.settings) {
      sections.push(this.generateSettings(config.settings));
    }
    
    // Generate request blocks
    for (const index of sortedIndices) {
      const entry = entries[index];
      const requestSection = this.generateRequestSection(
        entry,
        index,
        config
      );
      sections.push(requestSection);
    }
    
    // Add footer
    sections.push(this.generateFooter());
    
    // Join sections
    const script = sections.join('\n\n');
    
    // Validate generated script
    const validation = this.validator.validate(script);
    if (!validation.isValid) {
      console.error("Generated invalid LoliCode:", validation.errors);
      throw new Error(`Generated invalid LoliCode: ${validation.errors[0]}`);
    }
    
    return script;
  }
  
  /**
   * Validate configuration
   */
  private validateConfig(config: LoliCodeConfig, entryCount: number): void {
    if (!config.selectedIndices || config.selectedIndices.length === 0) {
      throw new Error('INVALID_CONFIG: No requests selected');
    }
    
    for (const index of config.selectedIndices) {
      if (index < 0 || index >= entryCount) {
        throw new Error(`INVALID_CONFIG: Invalid index ${index}`);
      }
    }
  }
  
  /**
   * Sort indices by dependency order
   */
  private sortByDependencies(
    indices: number[],
    matrix: DependencyMatrix
  ): number[] {
    return matrix.topologicalOrder.filter(i => indices.includes(i));
  }
  
  /**
   * Generate header comment
   */
  private generateHeader(): string {
    return `# ═══════════════════════════════════════════════════════════════
# Generated by HAR2LoliCode
# Date: ${new Date().toISOString()}
# Description: Automated script from HAR analysis
# ═══════════════════════════════════════════════════════════════`;
  }
  
  /**
   * Generate settings block
   */
  private generateSettings(settings: NonNullable<LoliCodeConfig['settings']>): string {
    const lines: string[] = ['SETTINGS'];
    
    if (settings.useProxy) {
      lines.push('  UseProxy: true');
    }
    
    if (settings.followRedirects !== undefined) {
      lines.push(`  FollowRedirects: ${settings.followRedirects}`);
    }
    
    if (settings.timeout) {
      lines.push(`  Timeout: ${settings.timeout}`);
    }
    
    if (settings.retryCount) {
      lines.push(`  RetryCount: ${settings.retryCount}`);
    }
    
    return lines.join('\n');
  }
  
  /**
   * Generate request section with all blocks
   */
  private generateRequestSection(
    entry: SemanticHarEntry,
    index: number,
    config: LoliCodeConfig
  ): string {
    const sections: string[] = [];
    
    // Add section comment
    sections.push(`# ─────────────────────────────────────────────────────────────`);
    sections.push(`# Request ${index + 1}: ${entry.request.method} ${new URL(entry.request.url).pathname}`);
    sections.push(`# ─────────────────────────────────────────────────────────────`);
    
    // Generate request block
    const requestBlock = this.requestBuilder.build(
      entry,
      config.customHeaders?.[index]
    );
    sections.push(requestBlock);
    
    // Generate variable extraction if configured
    if (config.variableExtractions?.[index]) {
      for (const extraction of config.variableExtractions[index]) {
        const parseBlock = this.parseBuilder.build(extraction);
        sections.push(parseBlock);
      }
    }
    
    // Generate assertions/keychecks
    if (config.customAssertions?.[index]) {
      for (const assertion of config.customAssertions[index]) {
        const keycheckBlock = this.keycheckBuilder.build(assertion);
        sections.push(keycheckBlock);
      }
    } else {
      // Default status check
      sections.push(this.keycheckBuilder.buildStatusCheck(entry.response.status));
    }
    
    // Add delay between requests
    sections.push('FUNCTION Delay "1000"');
    
    return sections.join('\n');
  }
  
  /**
   * Generate footer
   */
  private generateFooter(): string {
    return `# ═══════════════════════════════════════════════════════════════
# End of generated script
# ═══════════════════════════════════════════════════════════════`;
  }
}

// Export factory function
export function generateLoliCode(
  config: LoliCodeConfig,
  entries: SemanticHarEntry[],
  dependencyMatrix: DependencyMatrix
): string {
  const generator = new LoliCodeGenerator();
  return generator.generate(config, entries, dependencyMatrix);
}
